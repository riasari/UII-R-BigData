---
title: "Streaming advanced"
output: html_notebook
---

Load spark
```{r}
library(sparklyr)
library(dplyr)
library(future)
# library(arrow)
conf <- spark_config()
conf$`sparklyr.shell.driver-memory` <- "8G"
# Enable kryo to decrease serialization overhead
conf$spark.serializer <- "org.apache.spark.serializer.KryoSerializer"
spark <- spark_connect(master = "local", config = conf)
```

## generate some dummy data

```{r}
source <- "streaming_source"
destination <- "streaming_destination"
if(file.exists(source)) unlink(source, TRUE)
if(file.exists(destination)) unlink(destination, TRUE)


lenght_df <- 1000
dates <- base::sample(seq(as.Date('2018-01-01'), as.Date('2019-06-01'), by="day"), replace = TRUE, lenght_df)
values <- rnorm(lenght_df)

event_category <- base::sample(c("regular", "error", "security_alert"), lenght_df, replace = TRUE)
sampling_df <- data.frame(values, dates, event_category)
sampling_df <- sampling_df %>%
  rename(timestamp = dates) %>%
  rename(category = event_category) %>%
  rename(value = values)
head(sampling_df)

stream_generate_test(df = sampling_df, iterations = 1, path = source)
```


## Window Operations on Event Time

Aggregations over a sliding event-time window are straightforward with Structured Streaming and are very similar to grouped aggregations.

![illustration of above query](img/structured-streaming-window.png)

However, to run this query for days, itâ€™s necessary for the system to bound the amount of intermediate in-memory state it accumulates. Watermarking has been introduced just for this.
In R `stream_watermark(df, column="timestamp", threshold="10 minutes")` enables Watermarking.


![watermarking](img/structured-streaming-watermark-update-mode.png)

`window(timestamp,  "7 days", "3 days")` defines a sliding window over the timestamp column which has a size of 7 days and and slides over every 3 days.

```{r}
read_folder <- stream_read_csv(spark, source) 

process_stream <- read_folder %>%
  stream_watermark(column="timestamp", threshold="14 days") %>% 
  group_by(time_window = window(timestamp,  "7 days", "3 days"), category) %>%
  summarise(
    mean = mean(value, na.rm = TRUE),
    count = n()
  ) %>%
  sdf_separate_column("time_window", into=c("beginning", "end")) %>%
  select(-time_window) %>%
  arrange(desc(count))

my_table <- "stream"
write_output <- stream_write_memory(process_stream, name = my_table)
##########################################
tbl(spark, my_table)  # run once
##########################################

invisible(future(stream_generate_test(df = sampling_df, interval = 0.2, iterations = 100, path = source)))

##########################################
tbl(spark, my_table)  # execute repeatedly
##########################################
#stream_view(write_output)
```

### JOINs

As of Spark 2.3 also Stream-stream and not only stream-static joins are available.

> NOTE: this is still rather experimental and not well supported in the `dbplyr` tooling. Falling back to executing textual `SQL` is required for now. See https://github.com/rstudio/sparklyr/issues/1977 for details.

```{r}

```

### Triggers

- unspecified. Generates a new microbatch after the last one has finished.
- fixed micro batches, in R `stream_trigger_interval`
- run once https://databricks.com/blog/2017/05/22/running-streaming-jobs-day-10x-cost-savings.ht
- continous

```{r}
stream_trigger_interval()
```

Finally cleanup / stop butting in RStudio:
```{r}
stream_stop(write_output) # cleanup
```

## cleanup

Finally, close the spark session again.
```{r}
spark_disconnect(spark)
```